
\subsection{Пространственные индексы}
Как и с задачами поиска по \textit{плоскому} массиву скаляров, для поиска по геоточкам используются специальные структуры данных, которые позволяют оптимизировать операции поиска.

Указанные структуры можно разбить на 2 типа: древовидные и хэши со скалярным индексом. К первому виду относятся: R-tree, VP-tree, BSP-tree, Quadtree, KD-tree. К хэшам относятся: Geohash, S2 Geometry и Uber H3. Важно отметить, что недостаточно использовать

Рассмотрим принцип работы древовидных структур на примере KD tree, самого \textit{легкого} для понимания человеком пространственного индекса.

\subsubsection{K-d tree}
K-d tree представляет собой дерево, позволяющее производить операции поиска в N-мерном пространстве. Рассмотрим двухмерное K-d tree, которое также можно назвать K-2 tree.
Сама структура K-d tree является обычным бинарным деревом.
Алгоритм построения K-d tree довольно прост:
\begin{enumerate}
    \item Происходит поиск центральной точки, то есть той точки, которая будет находиться на суммарно меньшем расстоянии от всех точек. Данная точка ставиться в корень дерева k-d tree.
    \item Далее плоскость "разбивается" на 2 части по вертикальной оси
    \item "Слева" ищется "средняя точка", то есть та точка, которая по оси абсцисс(широте) находится на суммарно меньшем расстоянии до остальных. Данная точка записывает в левого ребенка корня дерева
    \item Аналогичная процедура повторяется справа.
    \item Аналогичная процедура повторяется для вновь созданных полотен, но уже с осью ординат(долготой)
    \item Данные процедуры повторяются со всеми точками.
\end{enumerate}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{kd-tree.jpg}
    \caption{Слева — пример визуализации разбиения плоскости через KD-tree. Справа - результат построения дерева}
\end{figure}

\subsubsection{KNN поиск по KD-tree}

Процесс поиска K ближайших соседей по KD-tree заключается в следующих шагах:

\begin{enumerate}
    \item Строим KD-tree из набора точек.
    \item Находим ближайшую к заданной точке точку в дереве. Для этого спускаемся по дереву, сравнивая координаты заданной точки и текущей точки в узле дерева. Если координата текущей точки больше или равна координате заданной точки, то спускаемся в левое поддерево, иначе - в правое. При этом сохраняем расстояние между текущей точкой и заданной точкой.
    \item Добавляем найденную точку в список ближайших соседей.
    \item Проверяем, есть ли еще точки в дереве, которые могут быть ближе к заданной точке, чем уже найденные соседи. Для этого проверяем расстояние между заданной точкой и границей текущего поддерева (это можно сделать, используя формулу расстояния между точками). Если это расстояние меньше, чем расстояние до самого дальнего найденного соседа, то нужно проверить и другое поддерево.
    \item Повторяем шаги 2-4 для всех точек в дереве, пока не найдем K ближайших соседей или не пройдем по всему дереву.
\end{enumerate}

В результате получаем список K ближайших соседей заданной точки. Этот алгоритм позволяет быстро находить ближайшие соседи в больших наборах данных и широко используется в геоинформационных системах для поиска ближайших объектов на карте.

\subsubsection{Поиск в круге по KD-tree}
Процесс поиска K ближайших точек и всех точек в заданном радиусе очень поход на процесс поиска по бинарному дереву за тем исключением, что при сравнении по четным нодам идет по широте, а по нечетным — по долготе.

Процесс заключается в следующих шагах:

\begin{enumerate}
    \item Строим KD-дерево на основе набора геоданных.
    \item Ищем листовой узел дерева, который содержит заданную точку. Для этого начинаем с корневого узла и спускаемся по дереву, выбирая каждый раз ту часть пространства, которая содержит заданную точку.
    \item Находим все точки, которые находятся в заданном круге с центром в заданной точке и радиусом R. Для этого проверяем каждую точку в листовом узле и всех его родительских узлах на расстояние до заданной точки. Если расстояние меньше или равно R, то добавляем точку в список найденных точек.
    \item Если листовой узел не содержит достаточного количества точек, то расширяем круг до тех пор, пока не найдем достаточное количество точек.
    \item Возвращаем список точек, которые находятся в заданном круге.
\end{enumerate}

Этот алгоритм обеспечивает точность поиска в пределах заданного радиуса и может быть эффективным для поиска ближайших соседей в небольших наборах геоданных. Однако он может быть менее эффективным для больших наборов данных или для поиска точек в нескольких кругах одновременно.

\subsubsection{Geohash}
Geohash (далее также геохеш) - представляет собой бинарной представление координат (широта-долгота). Сам геохэш не реализует алгоритмов поиска, поэтому для поиска по геохуше дополнительно используются такие структуры как B-tree, trie, Radix-trie и тд.
Самим геохешом называется строка, закодированная 32 разрядным алфавитом, перевод из 10-ой системы в указанный алфавит указан в таблице ниже.
\begin{center}
\begin{tabular}{ c|c c c c c c c c }
 Основание 10 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
 Основание 32 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
  \hline\hline
 Основание 10 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 \\
 Основание 32 & 8 & 9 & b & c & d & e & f & g \\
  \hline\hline
 Основание 10 & 16 & 17 & 18 & 19 & 20 & 21 & 22 & 23  \\
 Основание 32 & h & j & k & m & n & p & q & r \\
  \hline\hline
 Основание 10 & 24 & 25 & 26 & 27 & 28 & 29 & 30 & 31 \\
 Основание 32 & s & t & u & v & w & x & y & z \\
\end{tabular}
\end{center}
Данная строка однозначно декодируется в кортеж геокоординат с точностью, зависящей от количества символов в строке. Примеры:
\begin{enumerate}
    \item строка \texttt{ucft} дегодируется в прямоугольник площадью примерно 800 $ km^2 $ и центром в (55.81, 37.44).
    \item строка \texttt{ucft943} имеет тот же центр - (55.8236, 37.3116), но меньшую площадь $23409 m^2$
\end{enumerate}
Как можно наблюдать, чем выше количество символов, используемых в геохеше, чем выше точность получаемых координат, но при этом выше затрачиваемая память.
В данной работе не будет детально описываться процесс формирования геохеша за исключением базового принципа:

Сфера земли разбивается на практически равные прямоугольники, после чего каждому прямоугольнику присваивается номер в 32х-ричной системе координат, номера присваиваются в порядке "змейкой", сначала самый левый-верхний, далее ниже от него, далее справа от самого левого-верхнего и тд.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{geohash.png}
    \caption{Пример разбиения сферы земли через Geohash на первые 2 префикса}
\end{figure}

Для реализации поиска по геохешу можно использовать структуру B-tree, которая представляет собой дерево поиска. Эта структура на которой оптимизированы операции поиска по равенству, поиска по сравнению и поиска в диапазоне. Данный подход часто используется в связке с No-SQL СУБД, например, с DynamoDB, MongoDB или HBase\textsuperscript{[7]}.
Существует множество оптимизаций данных операций, например, структура GB-tree\textsuperscript{[6]} и MP-trie\textsuperscript{[10]}.
Ниже представлен пример с использованием B-tree\textsuperscript{[9]}.

\subsubsection{KNN поиск по Geohash}
Процесс поиска K ближайших соседей по geohash заключается в следующих шагах:
\begin{enumerate}
    \item Преобразуем координаты заданной точки в geohash строку определенной длины.
    \item Ищем все точки, которые находятся в ячейках, соответствующих префиксу geohash строки заданной точки. Для этого используем функцию декодирования, которая преобразует geohash строку в координаты прямоугольной области. Она содержит все ячейки с данным префиксом.
    \item Сортируем найденные точки по расстоянию до заданной точки и выбираем K ближайших соседей.
    \item Если количество найденных точек меньше K, то увеличиваем длину geohash строки и повторяем поиск, пока не найдем достаточное количество соседей.
    \item Возвращаем список K ближайших соседей заданной точки.
\end{enumerate}

Этот алгоритм позволяет быстро находить ближайшие соседи в больших наборах геоданных, используя простую и эффективную структуру индексации. Однако он не обеспечивает точность поиска в пределах определенного радиуса, как это делает KD-tree, и может потребовать дополнительной обработки данных для учета искривления поверхности Земли.

\subsubsection{Поиск по радиусу по Geohash}

Процесс поиска точек в заданном круге по Geohash заключается в следующих шагах:
\begin{enumerate}
    \item Конвертируем заданные координаты в Geohash строку.
    \item Определяем Geohash строки, которые находятся внутри заданного круга. Для этого используем формулу Хаверсина для вычисления расстояния между заданными координатами и каждой из ячеек Geohash, либо любую другую формулу вычисления расстояния в зависимости от заданных требований точности. Если расстояние меньше или равно радиусу круга, то добавляем эту Geohash строку в список.
    \item Ищем все точки, которые соответствуют найденным Geohash строкам. Для этого используем индекс, который связывает каждую Geohash строку с набором геоданных. Ищем все точки в наборе, которые соответствуют найденным Geohash строкам.
    \item Возвращаем список точек, которые находятся в заданном круге.
\end{enumerate}

Этот алгоритм обеспечивает быстрый поиск точек в заданном круге и может быть эффективным для высоко нагруженных систем, так как он позволяет быстро искать точки в больших наборах геоданных. Однако он может быть менее точным, чем KD-Tree, так как Geohash строки имеют фиксированный размер и точность.
