\section{1.2 Пространственные индексы}
Как и с задачами поиска по массиву скаляров, для поиска по геоточкам используются специальные структуры данных, которые позволяют оптимизировать указанные операции. 

Данные структуры можно разбить на 2 типа: древовидные и хэши со скалярным индексом. К первому виду относятся: R-tree, VP-tree, BSP-tree, Quadtree, KD-tree. К хэшам относятся: Geohash, S2 Geometry и Uber H3.

Рассмотрим принцип работы древовидных структур на примере KD-tree, самого простого для понимания человеком пространственного индекса.

\subsection{1.2.1 Дерево KD-tree}
KD-tree представляет собой дерево, позволяющее производить операции поиска в N-мерном пространстве. Рассмотрим двухмерное KD-tree, которое также можно назвать K-2 tree.
Сама структура KD-tree является обычным бинарным деревом, как показано на рисунке 1.
\par\vspace{1em}
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.2]{kd-tree.jpg}
    \caption{Слева — пример визуализации разбиения плоскости через KD-tree. Справа --- результат построения дерева}
\end{figure}

Алгоритм построения KD-tree довольно прост\cite{nnq}:
\par а) происходит поиск центральной точки, то есть той точки, которая будет находиться на суммарно меньшем расстоянии от всех точек. Данная точка ставится в корень дерева KD-tree;
\par б) далее плоскость разбивается на 2 части по вертикальной оси;
\par в) слева ищется средняя точка, то есть та точка, которая по оси абсцисс (широте) находится на суммарно меньшем расстоянии до остальных. Данная точка записывается в левого ребёнка корня дерева;
\par г) аналогичная процедура повторяется справа;
\par д) аналогичная процедура повторяется для вновь созданных полотен, но уже с осью ординат (долготой);
\par е) данные процедуры повторяются со всеми точками.

\subsection{1.2.2 Поиск KNN в KD-tree}

Процесс поиска K ближайших соседей по KD-tree заключается в следующих шагах:
\par а) строим KD-tree из набора точек;
\par б) находим ближайшую к заданной точке точку в дереве. Для этого спускаемся по дереву, сравнивая координаты заданной точки и текущей точки в узле дерева. Если координата текущей точки больше или равна координате заданной точки, то спускаемся в левое поддерево, иначе - в правое. При этом сохраняем расстояние между текущей точкой и заданной точкой;
\par в) добавляем найденную точку в список ближайших соседей;
\par г) проверяем, есть ли еще точки в дереве, которые могут быть ближе к заданной точке, чем уже найденные соседи. Для этого проверяем расстояние между заданной точкой и границей текущего поддерева (это можно сделать, используя формулу расстояния между точками). Если это расстояние меньше, чем расстояние до самого дальнего найденного соседа, то нужно проверить и другое поддерево;
\par д) повторяем шаги 2-4 для всех точек в дереве, пока не найдем K ближайших соседей или не пройдем по всему дереву.

В результате получаем список K ближайших соседей заданной точки. 

\subsection{1.2.3 Поиск в круге в KD-tree}
Процесс поиска K ближайших точек и всех точек в заданном радиусе очень похож на процесс поиска по бинарному дереву за тем исключением, что сравнение по четным нодам идет по широте, а по нечетным — по долготе. 

Процесс заключается в следующих шагах:
\par а) строим KD-дерево на основе набора геоданных;
\par б) ищем листовой узел дерева, который содержит заданную точку. Для этого начинаем с корневого узла и спускаемся по дереву, выбирая каждый раз ту часть пространства, которая содержит заданную точку;
\par в) находим все точки, которые находятся в заданном круге с центром в заданной точке и радиусом R. Для этого проверяем каждую точку в листовом узле и всех его родительских узлах на расстояние до заданной точки. Если расстояние меньше или равно R, то добавляем точку в список найденных точек;
\par г) возвращаем список точек, которые находятся в заданном круге.


\subsection{1.2.4 Дерево Quadtree}
Quadtree - это пространственный индекс, который представляет пространство в виде дерева. Крайне похож на KD-tree за тем исключением, что пространство делится на равные подпространства. Представление дерева на плоскости и в памяти ЭВМ показано на рисунке 2. 
\par\vspace{1em}
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.2]{quadtree.png}
    \caption{Слева --- пример визуализации разбиения плоскости через Quadtree. Справа — результат построения дерева}
\end{figure}
  
Процесс поиска точек в заданном круге по Quadtree:
\par а) конвертируем заданные координаты в координаты узла Quadtree. Это делается путем разбиения пространства на сетку и назначения каждой ячейке уникальных координат узла Quadtree;
\par б) определяем узлы Quadtree, которые находятся внутри заданного круга. Для этого используем формулу гаверсинуса для вычисления расстояния между заданными координатами и каждым узлом Quadtree. Если расстояние меньше или равно радиусу круга, то добавляем этот узел в список;
\par в) ищем все точки, которые соответствуют найденным узлам Quadtree. Для этого используем индекс, который связывает каждый узел Quadtree с набором геоданных. Ищем все точки в наборе, которые соответствуют найденным узлам Quadtree;
\par г) возвращаем список точек, которые находятся в заданном круге.


\subsection{1.2.5 Дерево R-tree}
R-tree - это пространственный индекс, который используется для хранения и поиска объектов в пространстве\cite{guttmanRtree}. Как показано на рисунке 3, R-tree представляет собой дерево, где каждый узел представляет собой прямоугольник, содержащий объекты. Этот индекс позволяет быстро находить объекты, которые находятся в заданном прямоугольнике или близко к нему. Логика работы данного индекса крайне похожа на логику индекса B-Tree, но для координат.
\par\vspace{1em}
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.2]{R-tree.png}
    \caption{Сверху — пример визуализации разбиения плоскости через R-tree. Снизу - результат построения дерева}
\end{figure}
  
Процесс поиска объектов в заданном прямоугольнике по R-tree:
\par а) конвертируем заданный прямоугольник в формат R-tree. Это делается путем определения минимального и максимального значения координат для каждого измерения;
\par б) ищем узлы R-tree, которые пересекаются с заданным прямоугольником. Для этого используем алгоритм пересечения прямоугольников, который позволяет быстро определить, какие узлы R-tree находятся внутри или пересекаются с заданным прямоугольником;
\par в) ищем все объекты, которые соответствуют найденным узлам R-tree. Для этого используем индекс, который связывает каждый узел R-tree с набором объектов. Ищем все объекты в наборе, которые соответствуют найденным узлам R-tree;
\par г) возвращаем список объектов, которые находятся в заданном прямоугольнике.


Важно отметить, что данная структура используется в большом количестве популярных СУБД: 
\par а) PostGIS - Расширение для СУБД PostgreSQL;
\par б) Redis - Key-value база данных;
\par в) Tile38 - Аналог Redis с углублением в работу с геоданными.

Таким образом данный индекс выигрывает по популярности у разработчиков. 

\subsection{1.2.6 Дерево R*-tree}
R*-tree представляет собой оптимизацию балансировки R-tree\cite{beckmannRStarTree}, благодаря которой операции поиска становятся быстрее, но при этом операция вставки замедляется за счет необходимости перестройки дерева. Необходимо подчеркнуть, что в указанных выше СУБД используется именно оригинальная версия дерева --- R-tree\cite{sunRStartree}. Данный факт обязует на практике протестировать разницу между деревьями и проанализировать причины такого выбора\cite{fedorovskieRTree}. 

\subsection{1.2.7 Индекс Bruteforce}
Для наиболее честного анализа качества работы индексов, требуется использовать контрольный индекс, который можно именовать как перебор (Bruteforce). Данный индекс представляет собой простой динамический массив, в который сохраняются все заданные точки. Данный массив можно использовать как самое «плохое» решение «в лоб», иными словами, если какой-то алгоритм или индекс работает хуже, чем перебор - значит данный индекс либо разработан неправильно, либо имеет слишком критические недостатки. 

Процесс поиска ближайших соседей:
\par а) вычислить матрицу расстояний от заданной точки до каждой точки массива;
\par б) отсортировать массив по расстояниям используя указанную матрицу;
\par в) взять первые K элементов.

Процесс поиска в прямоугольнике:
\par а) последовательно итерироваться по всем элементам массива и добавлять в результирующий массив все точки, чьи широты и долготы входят в прямоугольник.

\subsection{1.2.8 Дерево BSP-tree}
BSP-tree (Binary Space Partitioning tree) - это пространственный индекс, который используется для разбиения пространства на бинарные подпространства\cite{liuGBTree}. BSP-tree представляет собой бинарное дерево, где каждый узел представляет собой гиперплоскость, которая разделяет пространство на две части: левую и правую.

Процесс поиска ближайших соседей по BSP-tree заключается в следующих шагах:
\par а) строим BSP-tree из набора точек. Для этого выбираем случайную гиперплоскость и разбиваем набор точек на две группы: те, что находятся по одну сторону от гиперплоскости, и те, что находятся по другую сторону;
\par б) ищем ближайшую точку к заданной точке. Для этого начинаем с корня BSP-tree и рекурсивно спускаемся по дереву, выбирая поддерево, которое содержит более близкие к заданной точке точки. Если расстояние от гиперплоскости до заданной точки меньше, чем текущее расстояние до ближайшей точки, то ищем ближайшую точку в этом поддереве;
\par в) после этого проверяем, есть ли еще поддеревья, которые могут содержать более близкие точки, и продолжаем поиск.

\subsection{1.2.9 Дерево VP-tree}
VP-tree (Vantage Point tree) - это пространственный индекс, который используется для быстрого поиска ближайших соседей в многомерном пространстве. VP-tree представляет собой бинарное дерево, где каждый узел представляет собой точку-центр (опорная точка, как показано на рисунке 4). От указанной точки строятся два поддерева: левое поддерево содержит все точки, которые находятся внутри заданного радиуса от центра, а правое поддерево содержит все точки, которые находятся за пределами этого радиуса. Является разновидностью дерева BSP.

\par\vspace{1em}
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.8]{vp-tree.png}
    \caption{Разбиение пространства на 3 подпространства через VP-Tree}
\end{figure}
  
Процесс поиска ближайших соседей по VP-tree заключается в следующих шагах:
\par а) строим VP-tree из набора точек. Для этого выбираем случайную опорную точку и разбиваем набор точек на две группы: те, что находятся ближе к центру, и те, что находятся дальше от него;
\par б) ищем ближайшую точку к заданной точке. Для этого начинаем с корня VP-tree и рекурсивно спускаемся по дереву, выбирая поддерево, которое содержит более близкие к заданной точке точки. Если расстояние от центра поддерева до заданной точки меньше, чем текущее расстояние до ближайшей точки, то ищем ближайшую точку в этом поддереве;
\par в) после этого проверяем, есть ли еще поддеревья, которые могут содержать более близкие точки, и продолжаем поиск.


\subsection{1.2.10 Иные индексы}
В научном сообществе каждый год публикуются статьи с новыми индексами, например, MPTrie \cite{gantiMPTrie}, STHash\cite{guanSTHash} и другие. Большинство из них решают узконаправленные задачи, либо улучшают уже созданные индексы для работы в определенных условиях. В данной работе указанные индексы не рассматриваются из-за того, что их некорректно было бы сравнивать с R-Tree, KD-Tree и тд. из-за того, что, как уже было сказано, они реализованы под конкретную проблему. 