
\section{1.2 Пространственные индексы}
Как и с задачами поиска по \textit{плоскому} массиву скаляров, для поиска по геоточкам используются специальные структуры данных, которые позволяют оптимизировать операции поиска. 

Указанные структуры можно разбить на 2 типа: древовидные и хэши со скалярным индексом. К первому виду относятся: R-tree, VP-tree, BSP-tree, Quadtree, KD-tree. К хэшам относятся: Geohash, S2 Geometry и Uber H3.

Рассмотрим принцип работы древовидных структур на примере KD tree, самого \textit{легкого} для понимания человеком пространственного индекса.

\subsection{1.2.1 K-d tree}
K-d tree представляет собой дерево, позволяющее производить операции поиска в N-мерном пространстве. Рассмотрим двухмерное K-d tree, которое также можно назвать K-2 tree.
Сама структура K-d tree является обычным бинарным деревом, как показано на рисурнке 1.
  \\
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{kd-tree.jpg}
    \caption{Слева — пример визуализации разбиения плоскости через KD-tree. Справа - результат построения дерева}
\end{figure}
  \\
Алгоритм построения K-d tree довольно прост\cite{nnq}:
\begin{enumerate}
    \item Происходит поиск центральной точки, то есть той точки, которая будет находиться на суммарно меньшем расстоянии от всех точек. Данная точка ставиться в корень дерева k-d tree.
    \item Далее плоскость \textit{разбивается} на 2 части по вертикальной оси
    \item \textit{Слева} ищется \textit{средняя точка}, то есть та точка, которая по оси абсцисс(широте) находится на суммарно меньшем расстоянии до остальных. Данная точка записывает в левого ребенка корня дерева
    \item Аналогичная процедура повторяется справа.
    \item Аналогичная процедура повторяется для вновь созданных полотен, но уже с осью ординат (долготой)
    \item Данные процедуры повторяются со всеми точками.
\end{enumerate}

\subsection{1.2.2 KNN поиск по KD-tree}

Процесс поиска K ближайших соседей по KD-tree заключается в следующих шагах:

\begin{enumerate}
    \item Строим KD-tree из набора точек. 
    \item Находим ближайшую к заданной точке точку в дереве. Для этого спускаемся по дереву, сравнивая координаты заданной точки и текущей точки в узле дерева. Если координата текущей точки больше или равна координате заданной точки, то спускаемся в левое поддерево, иначе - в правое. При этом сохраняем расстояние между текущей точкой и заданной точкой.
    \item Добавляем найденную точку в список ближайших соседей.
    \item Проверяем, есть ли еще точки в дереве, которые могут быть ближе к заданной точке, чем уже найденные соседи. Для этого проверяем расстояние между заданной точкой и границей текущего поддерева (это можно сделать, используя формулу расстояния между точками). Если это расстояние меньше, чем расстояние до самого дальнего найденного соседа, то нужно проверить и другое поддерево.
    \item Повторяем шаги 2-4 для всех точек в дереве, пока не найдем K ближайших соседей или не пройдем по всему дереву.
\end{enumerate}

В результате получаем список K ближайших соседей заданной точки. Этот алгоритм позволяет быстро находить ближайшие соседи в больших наборах данных и широко используется в геоинформационных системах для поиска ближайших объектов на карте.

\subsection{1.2.3 Поиск в круге по KD-tree}
Процесс поиска K ближайших точек и всех точек в заданном радиусе очень поход на процесс поиска по бинарному дереву за тем исключением, что при сравнении по четным нодам идет по широте, а по нечетным — по долготе. 

Процесс заключается в следующих шагах:

\begin{enumerate}
    \item Строим KD-дерево на основе набора геоданных. 
    \item Ищем листовой узел дерева, который содержит заданную точку. Для этого начинаем с корневого узла и спускаемся по дереву, выбирая каждый раз ту часть пространства, которая содержит заданную точку.
    \item Находим все точки, которые находятся в заданном круге с центром в заданной точке и радиусом R. Для этого проверяем каждую точку в листовом узле и всех его родительских узлах на расстояние до заданной точки. Если расстояние меньше или равно R, то добавляем точку в список найденных точек.
    \item Если листовой узел не содержит достаточного количества точек, то расширяем круг до тех пор, пока не найдем достаточное количество точек.
    \item Возвращаем список точек, которые находятся в заданном круге.
\end{enumerate}


\subsection{1.2.4 Quadtree}
Quadtree - это пространственный индекс, который представляет пространство в виде дерева, где каждый узел представляет собой четыре дочерних узла. Этот индекс позволяет быстро искать точки в заданном круге, разбивая пространство на более мелкие части и проверяя только те части, которые находятся внутри круга. Представление дерева на плоскости и в памяти ЭВМ показано на рисунке 2. 
  \\
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{quadtree.png}
    \caption{Слева - пример визуализации разбиения плоскости через Quadtree. Справа — результат построения дерева}
\end{figure}
  \\
Процесс поиска точек в заданном круге по Quadtree заключается в следующих шагах:
\begin{enumerate}
    \item Конвертируем заданные координаты в координаты узла Quadtree. Это делается путем разбиения пространства на сетку и назначения каждой ячейке уникальных координат узла Quadtree.
    \item Определяем узлы Quadtree, которые находятся внутри заданного круга. Для этого используем формулу Хаверсина для вычисления расстояния между заданными координатами и каждым узлом Quadtree. Если расстояние меньше или равно радиусу круга, то добавляем этот узел в список.
    \item Ищем все точки, которые соответствуют найденным узлам Quadtree. Для этого используем индекс, который связывает каждый узел Quadtree с набором геоданных. Ищем все точки в наборе, которые соответствуют найденным узлам Quadtree.
    \item Возвращаем список точек, которые находятся в заданном круге.
\end{enumerate}


\subsection{1.2.5 R-tree}
R-tree - это пространственный индекс, который используется для хранения и поиска объектов в пространстве\cite{guttmanRtree}. Как показано на рисунке 3, R-tree представляет собой дерево, где каждый узел представляет собой прямоугольник, содержащий объекты. Этот индекс позволяет быстро находить объекты, которые находятся в заданном прямоугольнике или близко к нему.
  \\
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{R-tree.png}
    \caption{Сверху — пример визуализации разбиения плоскости через R-tree. Снизу - результат построения дерева}
\end{figure}
  \\
Процесс поиска объектов в заданном прямоугольнике по R-tree заключается в следующих шагах:

\begin{enumerate}
    \item Конвертируем заданный прямоугольник в формат R-tree. Это делается путем определения минимального и максимального значения координат для каждого измерения.
    \item Ищем узлы R-tree, которые пересекаются с заданным прямоугольником. Для этого используем алгоритм пересечения прямоугольников, который позволяет быстро определить, какие узлы R-tree находятся внутри или пересекаются с заданным прямоугольником.
    \item Ищем все объекты, которые соответствуют найденным узлам R-tree. Для этого используем индекс, который связывает каждый узел R-tree с набором объектов. Ищем все объекты в наборе, которые соответствуют найденным узлам R-tree.
    \item Возвращаем список объектов, которые находятся в заданном прямоугольнике.
\end{enumerate}

Важно отметить, что данная структуру используется в большом количестве популярных СУБД: 
\begin{enumerate}
    \item PostGIS - Расширение для СУБД PostgreSQL
    \item Redis - Key-value база данных
    \item Tile38 - Аналог Redis с углублением в работу с геоданными
\end{enumerate}
Таким образом данный индекс выигрывает в популярности у разработчиков. 

\subsubsection{1.2.6 R*-tree}
R*-tree представляет собой оптимизацию балансировки R-tree\cite{beckmannRStarTree}, благодаря которой операции поиска становятся быстрее, но при этом операция вставки замедляется за счет необходимости перестройки дерева. Необходимо подчеркнуть, что в указанных выше СУБД используется именно \textit{оригинальная} версия дерева - R-tree\cite{sunRStartree}. Данный факт обязует на практике протестировать разницу между деревьями и проанализировать причины такого выбора\cite{fedorovskieRTree}. 

\subsection{1.2.7 Bruteforce}
Для наиболее честного анализа качества работы индексов, требуется использовать контрольный индекс, который можно именовать как \textit{перебор} (Bruteforce). Данный индекс представляет собой простой динамический массив, в который сохраняются все заданные точки. Данный массив можно использовать как самое \textit{плохое} решение \textit{в лоб}, иными словами если какой-то алгоритм или индекс работает хуже, чем \textit{перебор} - значит данный индекс либо разработан неправильно, либо имеет слишком критические недостатки. 

Процесс поиска ближайших соседей
\begin{enumerate}
    \item Вычислить матрицу расстояний от заданной точки до каждой точки массива.
    \item Осортировать массив по расстояниям используя указанную матрицу
    \item Взять первые K элементов
\end{enumerate}

Процесс поиска в прямоугольнике
\begin{enumerate}
    \item Последовательно итерироваться по всем элементам массива и добавлять в результирующий массив все точки, чьи широты и долготы входят в прямоугольник
\end{enumerate}


\subsection{1.2.8 VP-tree}
VP-tree (Vantage Point tree) - это пространственный индекс, который используется для быстрого поиска ближайших соседей в многомерном пространстве. VP-tree представляет собой бинарное дерево, где каждый узел представляет собой точку-центр (вантажный пункт, как показано на рисунке 4), от которой строятся два поддерева: левое поддерево содержит все точки, которые находятся внутри заданного радиуса от центра, а правое поддерево содержит все точки, которые находятся за пределами этого радиуса.
  \\
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{vp-tree.png}
    \caption{Разбиения пространства на 3 подпространства через VP-Tree}
\end{figure}
  \\
Процесс поиска ближайших соседей по VP-tree заключается в следующих шагах:

\begin{enumerate}
    \item Строим VP-tree из набора точек. Для этого выбираем случайную точку-центр и разбиваем набор точек на две группы: которые находятся ближе к центру, и которые находятся дальше от него.
    \item Ищем ближайшую точку к заданной точке. Для этого начинаем с корня VP-tree и рекурсивно спускаемся по дереву, выбирая поддерево, которое содержит более близкие к заданной точке точки. Если расстояние от центра поддерева до заданной точки меньше, чем текущее расстояние до ближайшей точки, то ищем ближайшую точку в этом поддереве.
    \item Ищем k ближайших соседей к заданной точке. Для этого начинаем с корня VP-tree и рекурсивно спускаемся по дереву, выбирая поддерево, которое содержит более близкие к заданной точке точки. Если расстояние от центра поддерева до заданной точки больше, чем текущее расстояние до k-го ближайшего соседа, то не ищем в этом поддереве. Иначе ищем в этом поддереве и добавляем найденные точки в список ближайших соседей. После этого проверяем, есть ли еще поддеревья, которые могут содержать более близкие точки, и продолжаем поиск.
\end{enumerate}


\subsection{1.2.9 BSP-tree}
BSP-tree (Binary Space Partitioning tree) - это пространственный индекс, который используется для разбиения пространства на бинарные подпространства\cite{liuGBTree}. BSP-tree представляет собой бинарное дерево, где каждый узел представляет собой гиперплоскость, которая разделяет пространство на две части: левую и правую.

Процесс поиска ближайших соседей по BSP-tree заключается в следующих шагах:
\begin{enumerate}
    \item Строим BSP-tree из набора точек. Для этого выбираем случайную гиперплоскость и разбиваем набор точек на две группы: те, которые находятся по одну сторону от гиперплоскости, и те, которые находятся по другую сторону.
    \item Ищем ближайшую точку к заданной точке. Для этого начинаем с корня BSP-tree и рекурсивно спускаемся по дереву, выбирая поддерево, которое содержит более близкие к заданной точке точки. Если расстояние от гиперплоскости до заданной точки меньше, чем текущее расстояние до ближайшей точки, то ищем ближайшую точку в этом поддереве.
    \item Ищем k ближайших соседей к заданной точке. Для этого начинаем с корня BSP-tree и рекурсивно спускаемся по дереву, выбирая поддерево, которое содержит более близкие к заданной точке точки. Если расстояние от гиперплоскости до заданной точки больше, чем текущее расстояние до k-го ближайшего соседа, то не ищем в этом поддереве. Иначе ищем в этом поддереве и добавляем найденные точки в список ближайших соседей. После этого проверяем, есть ли еще поддеревья, которые могут содержать более близкие точки, и продолжаем поиск.
\end{enumerate}

\subsection{1.2.10 Иные индексы}
В научном сообществе каждый год публикуются статьи с новыми индексами, например, MPTrie \cite{gantiMPTrie}, STHash\cite{guanSTHash} и другие. Большинство из них решают довольно конкретные задачи, либо улучшают уже созданные индексы под определенные наборы данных. В данной работе указанные индексы не рассматриваются из-за того, что их некорректно было бы сравнивать с R-Tree, KD-Tree и тд. из-за того, что, как уже было сказано, они реализованы под конкретную задачу. 