
\subsection{Иные древовидные структуры данных}

\subsubsection{Quadtree}
Quadtree - это пространственный индекс, который представляет пространство в виде дерева, где каждый узел представляет собой четыре дочерних узла. Этот индекс позволяет быстро искать точки в заданном круге, разбивая пространство на более мелкие части и проверяя только те части, которые находятся внутри круга.

Процесс поиска точек в заданном круге по Quadtree заключается в следующих шагах:
\begin{enumerate}
    \item Конвертируем заданные координаты в координаты узла Quadtree. Это делается путем разбиения пространства на сетку и назначения каждой ячейке уникальных координат узла Quadtree.
    \item Определяем узлы Quadtree, которые находятся внутри заданного круга. Для этого используем формулу Хаверсина для вычисления расстояния между заданными координатами и каждым узлом Quadtree. Если расстояние меньше или равно радиусу круга, то добавляем этот узел в список.
    \item Ищем все точки, которые соответствуют найденным узлам Quadtree. Для этого используем индекс, который связывает каждый узел Quadtree с набором геоданных. Ищем все точки в наборе, которые соответствуют найденным узлам Quadtree.
    \item Возвращаем список точек, которые находятся в заданном круге.
\end{enumerate}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{quadtree.png}
    \caption{Слева - пример визуализации разбиения плоскости через Quadtree. Справа — результат построения дерева}
\end{figure}

Этот алгоритм обеспечивает быстрый поиск точек в заданном круге и может быть эффективным для высоко нагруженных систем, так как он позволяет быстро искать точки в больших наборах геоданных. Однако он может потребовать больше ресурсов для построения и поддержки индекса, чем, например, Geohash+b-tree.

\subsubsection{R-tree}
R-tree - это пространственный индекс, который используется для хранения и поиска объектов в пространстве. R-tree представляет собой дерево, где каждый узел представляет собой прямоугольник, содержащий объекты. Этот индекс позволяет быстро находить объекты, которые находятся в заданном прямоугольнике или близко к нему.

Процесс поиска объектов в заданном прямоугольнике по R-tree заключается в следующих шагах:

\begin{enumerate}
    \item Конвертируем заданный прямоугольник в формат R-tree. Это делается путем определения минимального и максимального значения координат для каждого измерения.
    \item Ищем узлы R-tree, которые пересекаются с заданным прямоугольником. Для этого используем алгоритм пересечения прямоугольников, который позволяет быстро определить, какие узлы R-tree находятся внутри или пересекаются с заданным прямоугольником.
    \item Ищем все объекты, которые соответствуют найденным узлам R-tree. Для этого используем индекс, который связывает каждый узел R-tree с набором объектов. Ищем все объекты в наборе, которые соответствуют найденным узлам R-tree.
    \item Возвращаем список объектов, которые находятся в заданном прямоугольнике.
\end{enumerate}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{R-tree.png}
    \caption{Сверху — пример визуализации разбиения плоскости через R-tree. Снизу - результат построения дерева}
\end{figure}

R-tree может быть эффективным для поиска объектов в пространстве, так как он позволяет быстро находить объекты, которые находятся в заданном прямоугольнике или близко к нему. Однако он может потребовать больше ресурсов для построения и поддержки индекса, чем Geohash и Quadtree. \\
Важно отметить, что данная структуру используется в большом количестве популярных СУБД: 
\begin{enumerate}
    \item PostGIS - Расширение для СУБД PostgreSQL
    \item Redis - Key-value база данных
    \item Tile38 - Аналог Redis с углублением в работу с геоданными
\end{enumerate}

\subsubsection{R*-tree}
R*-tree представляет собой оптимизацию балансировки R-tree\textsuperscript{[8]}, благодаря которой операции поиска становятся быстрее, но при этом операция вставки замедляется за счет необходимости перестройки дерева. Необходимо подчеркнуть, что в указанных выше СУБД используется именно "оригинальная" версия дерева - R-tree. Данный факт обязует на практике протестировать разницу между деревьями и проанализировать причины такого выбора. 

\subsubsection{VP-tree}
VP-tree (Vantage Point tree) - это пространственный индекс, который используется для быстрого поиска ближайших соседей в многомерном пространстве. VP-tree представляет собой бинарное дерево, где каждый узел представляет собой точку-центр (вантажный пункт), от которой строятся два поддерева: левое поддерево содержит все точки, которые находятся внутри заданного радиуса от центра, а правое поддерево содержит все точки, которые находятся за пределами этого радиуса.

Процесс поиска ближайших соседей по VP-tree заключается в следующих шагах:

\begin{enumerate}
    \item Строим VP-tree из набора точек. Для этого выбираем случайную точку-центр и разбиваем набор точек на две группы: которые находятся ближе к центру, и которые находятся дальше от него.
    \item Ищем ближайшую точку к заданной точке. Для этого начинаем с корня VP-tree и рекурсивно спускаемся по дереву, выбирая поддерево, которое содержит более близкие к заданной точке точки. Если расстояние от центра поддерева до заданной точки меньше, чем текущее расстояние до ближайшей точки, то ищем ближайшую точку в этом поддереве.
    \item Ищем k ближайших соседей к заданной точке. Для этого начинаем с корня VP-tree и рекурсивно спускаемся по дереву, выбирая поддерево, которое содержит более близкие к заданной точке точки. Если расстояние от центра поддерева до заданной точки больше, чем текущее расстояние до k-го ближайшего соседа, то не ищем в этом поддереве. Иначе ищем в этом поддереве и добавляем найденные точки в список ближайших соседей. После этого проверяем, есть ли еще поддеревья, которые могут содержать более близкие точки, и продолжаем поиск.
\end{enumerate}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{vp-tree.png}
    \caption{Разбиения пространства на 3 подпространства через VP-Tree}
\end{figure}

\subsubsection{BSP-tree}
BSP-tree (Binary Space Partitioning tree) - это пространственный индекс, который используется для разбиения пространства на бинарные подпространства. BSP-tree представляет собой бинарное дерево, где каждый узел представляет собой гиперплоскость, которая разделяет пространство на две части: левую и правую.

Процесс поиска ближайших соседей по BSP-tree заключается в следующих шагах:
\begin{enumerate}
    \item Строим BSP-tree из набора точек. Для этого выбираем случайную гиперплоскость и разбиваем набор точек на две группы: те, которые находятся по одну сторону от гиперплоскости, и те, которые находятся по другую сторону.
    \item Ищем ближайшую точку к заданной точке. Для этого начинаем с корня BSP-tree и рекурсивно спускаемся по дереву, выбирая поддерево, которое содержит более близкие к заданной точке точки. Если расстояние от гиперплоскости до заданной точки меньше, чем текущее расстояние до ближайшей точки, то ищем ближайшую точку в этом поддереве.
    \item Ищем k ближайших соседей к заданной точке. Для этого начинаем с корня BSP-tree и рекурсивно спускаемся по дереву, выбирая поддерево, которое содержит более близкие к заданной точке точки. Если расстояние от гиперплоскости до заданной точки больше, чем текущее расстояние до k-го ближайшего соседа, то не ищем в этом поддереве. Иначе ищем в этом поддереве и добавляем найденные точки в список ближайших соседей. После этого проверяем, есть ли еще поддеревья, которые могут содержать более близкие точки, и продолжаем поиск.
\end{enumerate}

BSP-tree похож по своим характеристикам на VP-tree, он может быть эффективным для поиска ближайших соседей в многомерном пространстве, так как он позволяет быстро находить ближайшие точки, используя разбиение на поддеревья. Однако также как с VP-tree, он тяжеловесен - он может потребовать больше ресурсов для построения и поддержки индекса, чем Geohash и Quadtree. 

\subsection{Иные методы геохеширования}
\subsubsection{Uber H3}
Uber H3 - это сетка гексагональных ячеек, которая используется сериализации и хранения геоданных в приложениях компании Uber, которая, собственно, и разработала данную систему. Каждая ячейка имеет уникальный идентификатор и может быть использована для определения местоположения объектов. Логика работы Uber H3 аналогична логики Geohash за основным исключением, что в Uber H3 используются шестиугольники, а в Geohash - прямоугольники. 

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{h3.png}
    \caption{Разбиение сферы земли на шестиугольники при использовании H3}
\end{figure}

Сравнение Uber H3 и Geohash:
\begin{enumerate}
    \item Размер ячеек: В Geohash размер ячеек зависит от уровня разбиения, тогда как в Uber H3 размер ячеек фиксирован и зависит от уровня разбиения.
    \item Форма ячеек: В Geohash ячейки имеют форму прямоугольников, тогда как в Uber H3 ячейки имеют форму правильных шестиугольников.
    \item Идентификаторы: В Geohash идентификаторы ячеек представляются строками, тогда как в Uber H3 идентификаторы представляются числами.
    \item Пространственная точность: В Geohash пространственная точность зависит от уровня разбиения, тогда как в Uber H3 пространственная точность зависит от размера ячеек.
    \item Поддержка многомерных данных: Uber H3 поддерживает многомерные данные, такие как время и высота, тогда как Geohash не поддерживает такие данные.
    \item Эффективность: Считается, что Uber H3 быстрее и эффективнее, чем Geohash, при работе с большими объемами данных. Данный тезис будет проверять в практической части данной работы. 
    \item Назначение: Geohash хорошо подходит для геопоиска и геоиндексации в небольших масштабах, тогда как Uber H3 хорошо подходит для геопоиска и геоиндексации в высоко нагруженных системах с большим объемом данных.
\end{enumerate}

Таким образом, выбор между Uber H3 и Geohash зависит от конкретных требований приложения. Если необходима высокая эффективность и поддержка многомерных данных, то лучше использовать Uber H3. Если требуется простота и удобство использования в небольших масштабах, то Geohash может быть более подходящим выбором.

\subsubsection{S2 geometry}

S2 Geometry - это библиотека для работы с геометрическими объектами на сфере, разработанная компанией Google. 

Основой S2 Geometry является иерархическая структура данных, называемая S2 Cell. Каждая ячейка S2 Cell представляет собой квадрат на сфере, который может быть разбит на более мелкие квадраты более высокого уровня. Уровень ячейки определяется числом n, которое указывает на количество разбиений квадрата на подквадраты. Чем больше значение n, тем меньше размер каждой ячейки.

S2 Geometry имеет ряд преимуществ перед Geohash. Во-первых, S2 Geometry использует более точную геометрическую модель, которая позволяет более точно представлять объекты на сфере. Во-вторых, S2 Geometry имеет более эффективный алгоритм поиска ближайших объектов, что делает ее идеальной для использования в приложениях, где требуется быстрый поиск объектов в заданном радиусе. В-третьих, S2 Geometry лучше масштабируется, что делает ее идеальной для использования в высоко нагруженных системах.

Однако у Geohash есть свои преимущества. Во-первых, Geohash проще в использовании и имеет более простую структуру данных, что делает его более доступным для новичков. Во-вторых, Geohash имеет более широкую поддержку в различных языках программирования, что делает его более универсальным и гибким.


\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{s2-geometry.jpg}
    \caption{Пример разбиения пространства на области с использованием S2 Geometry}
\end{figure}

Таким образом, выбор между S2 geometry и Geohash зависит от конкретных требований приложения. Если необходима высокая эффективность и поддержка многомерных данных, то лучше использовать S2 geometry. Но, как и в случае с H3, Geohash более прост и популярен, поэтому требуется меньше человеческих ресурсов для разработки.
